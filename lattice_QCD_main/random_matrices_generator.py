#########################################################################################################################################################################################################
#module that generates both the random matrices necessary to initialize the links and matrices R necessary during the update

#initialize each link with unitary_matrix_generator() and take R matrices for the update from te array R[] generated by random_matrices()

#########################################################################################################################################################################################################

import numpy as np
import random
from numpy import linalg as lg 
from numba import jit

eps = 0.24


#@jit(nopython = True)
def create_hermitean():
    M = np.zeros((3,3),dtype = complex)
    for i in range(0,3):
        for j in range(i,3):
            u = random.uniform(0,1)
            if (u>0.5):
                n = 1
            else:
                n = -1
            if (i ==j):
                M[i][i]= n
            else:
                M[i][j] = n
                M[j][i] = n
    return M
                
def printing_matrix(M):
    for i in range(0,3):
        for j in range(0,3):
            print("M[%d][%d] = " % (i,j))
            print(' {:.2f}'.format(M[i][j]))
    
            
            
def converter(M):
    U = np.identity(3,dtype = complex)
    U = U + 1j*M*eps
    q,r = lg.qr(U)
    norm = lg.norm(q,axis = 1)
    return q
# printing_matrix(M)
#printing_matrix(np.dot(q,np.transpose(np.conjugate(q))))
#print("norm = ")
#print(' {:.2f}'.format(np.absolute(lg.det(q))))
#print("%f %f %f" % (norm[0],norm[1],norm[2]))
### python list that contain the 100 random matrices

def unitary_matrix_generator():
    M = create_hermitean()
    U = converter(M)
    #printing_matrix(np.dot(U,np.transpose(np.conjugate(U))))
    return U

def random_matrices():
    R = []
    for i in range(0,100):
        U = unitary_matrix_generator()
        Udag = np.transpose(np.conjugate(U))
        R.append(U.copy())
        R.append(Udag.copy())
    return R
        
        
#M = create_hermitean()
#q = converter(M)
#printing_matrix(q)

        
        




